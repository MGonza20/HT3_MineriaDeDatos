---
title: "notebook"
output: html_document
date: "2023-03-02"
editor_options: 
  markdown: 
    wrap: 72
---

# Hoja de trabajo 03 - Regresión Lineal

```{r libraries}
library(dplyr)
library(knitr)
library(ggplot2)
library(cluster)
library(factoextra)
require(caret)
```

```{r confi dplyr}
options(dplyr.summarise.inform = FALSE)
```

```{r train data}
data <- read.csv("train.csv")
```

## Análisis Exploratorio

### ¿Cuál es la Zona más cara?

```{r average_price_per_zone}
grouped_data <- data %>% group_by(MSZoning)
agg_tbl <- grouped_data %>% summarise(median(SalePrice))
grouped_dataset <- as.data.frame(agg_tbl)
colnames(grouped_dataset)[colnames(grouped_dataset) == "MSZoning"] ="Zona"
colnames(grouped_dataset)[colnames(grouped_dataset) == "median(SalePrice)"] ="Promedio de Precio (USD)"
grouped_dataset <- grouped_dataset[order(grouped_dataset$`Promedio de Precio (USD)`, decreasing = TRUE), ]
kable(grouped_dataset, caption = "Promedio de ventas por cada zona")
```

Un 50% de las casas en la zona `Floating Village Residential` se venden
por arriba de los 205940.00 USD. Posteriormente sigue
`Residential Low Density`.

### ¿En qué vecindario se ubican las casas con mayor área en su terreno?

```{r area_per_neighborhood}
grouped_area_data <- data %>% group_by(Neighborhood)
area_with_median <- grouped_area_data %>% summarise(median(LotArea))
grouped_dataset_lot <- as.data.frame(area_with_median)
colnames(grouped_dataset_lot)[colnames(grouped_dataset_lot) == "Neighborhood"] ="Vecindario"
colnames(grouped_dataset_lot)[colnames(grouped_dataset_lot) == "median(LotArea)"] ="Area del terreno ft^2"
grouped_dataset_lot <- grouped_dataset_lot[order(grouped_dataset_lot$`Area del terreno ft^2`, decreasing = TRUE), ]
kable(grouped_dataset_lot[0:5,], caption = "Mediana de area por cada vecindario")
```

```{r plot_area_per_neighborhood}
ggplot(grouped_dataset_lot[0:5,], aes(x=Vecindario, y=`Area del terreno ft^2`)) +
geom_bar(stat="identity", fill="steelblue") 
```

La información nos demuestra que Clear Creek es el vecindario que tiene
los terrenos con mayor área. Un 50% de los terrenos tiene un área mayor
a 17575.0 pies cuadrados.

### ¿En qué año hubo más remodelaciones?

```{r remodelation_by_year}
data_with_remodelation <- data[data$YearBuilt != data$YearRemodAdd,]
```

En el dataset hay `r nrow(data_with_remodelation)` registros de casas
que fueron remodeladas. A continuación agrupamos por año la cantidad de
remodelaciones.

```{r group_remodelation_by_year}
grouped_remodelation_data <- data_with_remodelation %>% group_by(YearRemodAdd)
year_with_count <- grouped_remodelation_data %>% summarise(total_count=n(),
            .groups = 'drop')

grouped_remodelation <- as.data.frame(year_with_count)
colnames(grouped_remodelation)[colnames(grouped_remodelation) == "YearRemoAdd"] ="Año"
colnames(grouped_remodelation)[colnames(grouped_remodelation) == "total_count"] ="Cantidad de casas remodeladas"
grouped_remodelation <- grouped_remodelation[order(grouped_remodelation$`Cantidad de casas remodeladas`, decreasing = TRUE), ]
kable(grouped_remodelation[0:5,], caption = "Numero de casas Remodeladas por año")

```

Los 5 años con más casas remodeladas son 1950, 2006, 2007, 2005 y 2000
respectivamente. Es importante notar que en 1950 hay mucha más
diferencia que con los demás años.

```{r}
most_remodelated_zone_1950 <- tail(names(sort(table(data_with_remodelation[data_with_remodelation$YearRemodAdd == "1950",]$MSZoning))), 1)

most_remodelated_zone_2006 <- tail(names(sort(table(data_with_remodelation[data_with_remodelation$YearRemodAdd == "2006",]$MSZoning))), 1)

most_remodelated_zone_2007 <- tail(names(sort(table(data_with_remodelation[data_with_remodelation$YearRemodAdd == "2007",]$MSZoning))), 1)

```

La mayoría de las remodelaciones pertenecen a la zona
`RL - Residencial de baja densidad`.

### ¿Cuáles son los materiales más utilizados para la fundación de las casas?

```{r most_used_foundation}
grouped_foundation_data <- data %>% group_by(Foundation)
foundation_with_count <- grouped_foundation_data %>% summarise(total_count=n(),
            .groups = 'drop')

grouped_foundation <- as.data.frame(foundation_with_count)
colnames(grouped_foundation)[colnames(grouped_foundation) == "Foundation"] ="Material para la base"
colnames(grouped_foundation)[colnames(grouped_foundation) == "total_count"] ="Cantidad de casas"
grouped_foundation <- grouped_foundation[order(grouped_foundation$`Cantidad de casas`, decreasing = TRUE), ]
kable(grouped_foundation[0:5,], caption = "Numero de casas por cada material de base")

```

La mayoría de casas están hechas de concreto. Puede ser que un tipo
menos común, pero más caro, como el ladrillo signifique un precio más
alto.

### ¿Qué tipos de casa son más comunes?

```{r}
grouped_type_data <- data %>% group_by(BldgType)
type_count <- grouped_type_data %>% summarise(total_count=n(), .groups = 'drop')

grouped_type <- as.data.frame(type_count)
colnames(grouped_type)[colnames(grouped_type) == "BldgType"] ="Tipo de casa"
colnames(grouped_type)[colnames(grouped_type) == "total_count"] ="Cantidad"
grouped_type <- grouped_type[order(grouped_type$`Cantidad`, decreasing = TRUE), ]
kable(grouped_type[0:5,], caption = "Conteo de tipo de casas")

```

### ¿Cómo varia el precio de las casas según el vecindario en que se encuentran?

```{r}
grouped_data <- data %>% group_by(Neighborhood)
agg_tbl <- grouped_data %>% summarise(mean(SalePrice))
grouped_dataset <- as.data.frame(agg_tbl)
colnames(grouped_dataset)[colnames(grouped_dataset) == "Neighborhood"] ="Vecindario"
colnames(grouped_dataset)[colnames(grouped_dataset) == "mean(SalePrice)"] ="Promedio de Precio (USD)"
grouped_dataset <- grouped_dataset[order(grouped_dataset$`Promedio de Precio (USD)`, decreasing = TRUE), ]
kable(grouped_dataset, caption = "Promedio de ventas por cada vecindario")
```

### ¿Que proporción de casas se encuentra en cada zona?

```{r}
zone_counts <- data %>% count(MSZoning) %>% mutate(Proporcion = prop.table(n) * 100) %>% 
rename(Zona = MSZoning, Cantidad = n) %>% mutate(Proporcion = paste0(round(Proporcion, 2), "%")) %>%
arrange(desc(Proporcion))
kable(zone_counts, caption = "Proporción de casas por zona")
```

### ¿Cuáles son las características más comunes de las casas que se venden por encima del precio medio?

```{r}
price_mean_up <- mean(data$SalePrice)
houses_mean_above <- subset(data, SalePrice > price_mean_up)
ggplot(data = houses_mean_above, aes(x = MSZoning)) +geom_bar()
ggplot(data = houses_mean_above, aes(x = BldgType)) +geom_bar()
ggplot(data = houses_mean_above, aes(x = HouseStyle)) +geom_bar()
ggplot(data = houses_mean_above, aes(x = GarageType)) +geom_bar()
```

Las características más comunes son las siguientes: 1) Zona donda se
ubica las casas: RL (Casa residencial de baja densidad) 2) Tipo de
vivienda: 1Fam (Unifamiliar) 3) Estilo de la casa: 1Story (Un nivel) 4)
Tipo de Garaje: Attchd (Adjuntada a la casa)

### ¿Cuántas casas tienen piscina o garaje? ¿Como se relacionan estas características con el precio de venta?

```{r}
print("Counting Pools And Garages")
nrow(data) - table(data$PoolArea > 0)
nrow(data) - nrow(data[data$GarageType=="NA",])
print("")
print("Relation with the seal price")
tapply(data$SalePrice, data$PoolQC > 0, mean)
tapply(data$SalePrice, data$GarageType=="NA", mean)

```

1453 casas tienen psicina 1379 casas cuentan con garaje

Como se puede ver si influyen la relación con el precio, las psicinas
suelen elevar el precio de las casas

### ¿Cómo se distribuyen las ventas de casas a lo largo del tiempo entre los diferentes periodos?

```{r}
ggplot(data = data, aes(x = factor(YrSold))) +
  geom_bar(fill = "green") +
  ggtitle("Ventas de casas por año") +
  xlab("Año") +
  ylab("Cantidad de ventas")

ggplot(data = data, aes(x = YrSold, y = SalePrice)) +
  geom_line(color = "green") +
  ggtitle("Tendencia del precio de venta") +
  xlab("Año") +
  ylab("Precio de venta promedio")
```

Como se puede ver en las dos gráficas presentadas desde el año 2006 al
2009 existio una tendencia donde subía y bajan las ventas de las casas.
Pero desde 2010 este fue en bajando.

### Preprocesamiento de datos



```{r neihborhood values}
columns_used <- c()
neighborhoodNames <- c("NoRidge", "NridgHt", "StoneBr", "Timber", "Veenker", "Somerst", "ClearCr", "Crawfor", "CollgCr", "Blmngtn", "Gilbert", "NWAmes", "SawyerW", "Mitchel", "NAmes", "NPkVill", "SWISU", "Blueste", "Sawyer", "OldTown", "Edwards", "BrkSide", "BrDale", "IDOTRR", "MeadowV")

for(n in 1:length(neighborhoodNames)) {
  # Variable minuscula para nuestro uso.
  data$neighborhood[data$Neighborhood == neighborhoodNames[n]] <- n
}
columns_used <- append(columns_used, "neighborhood")

hs <- c("1Story", "2Story",	"1.5Fin",	"SLvl", "SFoyer")

for(n in 1:length(hs)) {
  # Variable minuscula para nuestro uso.
  data$houseStyle[data$HouseStyle == hs[n]] <- n
}
columns_used <- append(columns_used, "houseStyle")

 data$houseZone[data$MSZoning == "A"] <- 1
 data$houseZone[data$MSZoning == "C"] <- 2
 data$houseZone[data$MSZoning == "FV"] <- 3
 data$houseZone[data$MSZoning == "I"] <- 4
 data$houseZone[data$MSZoning == "RH"] <- 5
 data$houseZone[data$MSZoning == "RL"] <- 6
 data$houseZone[data$MSZoning == "RP"] <- 7
 data$houseZone[data$MSZoning == "RM"] <- 8
 columns_used <- append(columns_used, "houseZone")

data$houseUtilities[data$Utilities == "AllPub"] <- 1
data$houseUtilities[data$Utilities == "NoSewr"] <- 2
data$houseUtilities[data$Utilities == "NoSeWa"] <- 3
data$houseUtilities[data$Utilities == "ELO"] <- 4
columns_used <- append(columns_used, "houseUtilities")

data$roadAccess[data$Condition1 == "Artery"] <- 1
data$roadAccess[data$Condition1 == "Feedr"] <- 2
data$roadAccess[data$Condition1 == "Norm"] <- 3
data$roadAccess[data$Condition1 == "RRNn"] <- 4
data$roadAccess[data$Condition1 == "RRAn"] <- 5
data$roadAccess[data$Condition1 == "PosN"] <- 6
data$roadAccess[data$Condition1 == "PosA"] <- 7
data$roadAccess[data$Condition1 == "RRNe"] <- 8
data$roadAccess[data$Condition1 == "RRAe"] <- 9
columns_used <- append(columns_used, "roadAccess")

data$remodelated[data$YearBuilt != data$YearRemodAdd] <- 1
data$remodelated[data$YearBuilt == data$YearRemodAdd] <- 0
columns_used <- append(columns_used, "remodelated")

data$roofStyle[data$RoofStyle == "Flat"]  <- 1
data$roofStyle[data$RoofStyle == "Gable"]  <- 2
data$roofStyle[data$RoofStyle == "Gambrel"]  <- 3
data$roofStyle[data$RoofStyle == "Hip"]  <- 4
data$roofStyle[data$RoofStyle == "Mansard"]  <- 5
data$roofStyle[data$RoofStyle == "Shed"]  <- 6
columns_used <- append(columns_used, "roofStyle")

data$roofMaterial[data$RoofMatl == "ClyTile"] <- 1
data$roofMaterial[data$RoofMatl == "CompShg"] <- 2
data$roofMaterial[data$RoofMatl == "Membran"] <- 3
data$roofMaterial[data$RoofMatl == "Metal"] <- 4
data$roofMaterial[data$RoofMatl == "Roll"] <- 5
data$roofMaterial[data$RoofMatl == "Tar&Grv"] <- 6
data$roofMaterial[data$RoofMatl == "WdShake"] <- 7
data$roofMaterial[data$RoofMatl == "WdShngl"] <- 8
columns_used <- append(columns_used, "roofMaterial")

data$exteriorCondition[data$ExterCond == "Po"] <- 1
data$exteriorCondition[data$ExterCond == "Fa"] <- 2
data$exteriorCondition[data$ExterCond == "TA"] <- 3
data$exteriorCondition[data$ExterCond == "Gd"] <- 4
data$exteriorCondition[data$ExterCond == "Ex"] <- 5
columns_used <- append(columns_used, "exteriorCondition")

data$foundationMaterial[data$Foundation == "BrkTil"] <- 1
data$foundationMaterial[data$Foundation == "CBlock"] <- 2
data$foundationMaterial[data$Foundation == "PConc"] <- 3
data$foundationMaterial[data$Foundation == "Slab"] <- 4
data$foundationMaterial[data$Foundation == "Stone"] <- 5
data$foundationMaterial[data$Foundation == "Wood"] <- 6
columns_used <- append(columns_used, "foundationMaterial")

data$basement[is.na(data$BsmtQual)] <- 0
data$basement[!is.na(data$BsmtQual)] <- 1
columns_used <- append(columns_used, "basement")

data$basementCondition[data$BsmtCond == "Ex"] <- 3
data$basementCondition[data$BsmtCond == "Gd"] <- 2
data$basementCondition[data$BsmtCond != "Ex"] <- 1
data$basementCondition[data$BsmtCond != "Gd"] <- 1
data$basementCondition[is.na(data$BsmtCond)] <- 0
columns_used <- append(columns_used, "basementCondition")

data$fireplace[is.na(data$FireplaceQu)] <- 0
data$fireplace[!is.na(data$FireplaceQu)] <- 1
columns_used <- append(columns_used, "fireplace")

data$garageArea <- data$GarageArea
columns_used <- append(columns_used, "garageArea")

data$pool[is.na(data$PoolQC)] <- 0
data$pool[!is.na(data$PoolQC)] <- 1
columns_used <- append(columns_used, "pool")

data$additionalFeature[is.na(data$MiscFeature)] <- 0
data$additionalFeature[!is.na(data$MiscFeature)] <- 1
columns_used <- append(columns_used, "additionalFeature")

data$yearBuilt <- data$YearBuilt
columns_used <- append(columns_used, "yearBuilt")


data$salePrice <- data$SalePrice
columns_used <- append(columns_used, "salePrice")

tv <- c("WD", "Oth", "New", "ConLw", "ConLI", "ConLD", "Con", "CWD", "COD")

for(n in 1:length(tv)) {
  # Variable minuscula para nuestro uso.
  data$saleType[data$SaleType == tv[n]] <- n
}
columns_used <- append(columns_used, "saleType")

msz <- c("FV", "RL", "RH", "RM" , "C (all)")

for(n in 1:length(msz)) {
  # Variable minuscula para nuestro uso.
  data$mSZoning[data$MSZoning == msz[n]] <- n
}
columns_used <- append(columns_used, "mSZoning")

```

### Borrando valores inneceesarios

```{r}
cleanData <- subset(data, select = columns_used)
```


### Dividiendo los datos en entrenamiento y prueba
Dividimos el test de datos en un 75% para entrenamiento y un 25% para pruebas. Utilizamos el metodo de bootstraping porque nos asegura que la distribución de la data toma en cuenta la población total. Es decir, no tendremos un sesgo genrado por cómo la información está organizada.
``` {r}
expectedResult <- cleanData$salePrice
partition <- createDataPartition(y=expectedResult,
                                 p=.75,
                                 list=F)

trainingSet <- cleanData[partition,]
testingSet <- cleanData[-partition,]
```

### Clustering

Agrupamiento de las columnas más importantes
``` {r}
# Definir las columnas más importantes
important_cols <- c("YrSold", "SalePrice", "YearBuilt", "YearRemodAdd", "PoolArea", "GarageArea", "OverallQual", "OverallCond", "LotFrontage", "LotArea", "GarageCars")
# Normalizar variables numericas
cols_num_norm <- data[,important_cols] <- mutate_if(data[,important_cols], is.numeric, scale)
```

Resumen de las columnas a utilizar para llevar a cabo el clustering
```{r}
print(summary(data[,important_cols]))
```

Evaluación Visual de Tendencia de la data
``` {r}
data_dist <- dist(data[,1:4])
fviz_dist(data_dist, show_labels=F)
```



